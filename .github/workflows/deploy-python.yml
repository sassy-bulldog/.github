name: 'Deploy Python'

permissions:
  contents: read
  id-token: write

on:
  workflow_call:
    inputs:
      runs-on:
        description: Additional required tags for the pipeline agents to use.
        required: true
        type: string
      working-directory:
        description: 'Directory to use for deployment'
        type: string
        required: false
        default: ./
      environment:
        description: Environment to deploy to (dev, staging, prod)
        type: string
        required: true
      artifact-name:
        description: Name of the artifact to download from build
        type: string
        required: true
      version:
        description: Semantic version being deployed
        type: string
        required: false
        default: 0.0.1-alpha
      python-version:
        description: Python version for deployment
        type: string
        required: false
        default: '3.11'
      registry-url:
        description: Container registry URL for Docker deployments
        type: string
        required: false
        default: ''
      deployment-target:
        description: Deployment target (package, docker, k8s, serverless, pypi)
        type: string
        required: false
        default: 'package'

    secrets:
      DEPLOY_TOKEN:
        description: Token for deployment authentication
        required: false
      REGISTRY_PASSWORD:
        description: Container registry password
        required: false
      PYPI_TOKEN:
        description: Token for publishing to PyPI
        required: false

jobs:
  deploy:
    name: Deploy Python application
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    environment: ${{ inputs.environment }}

    steps:
      - name: Clean Agent Workspace
        uses: tiacsys/clean-after-action@v3.0.0

      - name: Checkout Repo
        uses: actions/checkout@v5.0.0

      - name: Set up Python
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ inputs.python-version }}

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: ${{ inputs.artifact-name }}
          path: ./artifacts

      - name: Install deployment dependencies
        run: |
          python -m pip install --upgrade pip
          pip install twine wheel

      - name: Deploy Python package
        if: inputs.deployment-target == 'package'
        run: |
          echo "Deploying Python package to ${{ inputs.environment }}"
          
          # Install the package locally for testing
          for wheel in ./artifacts/*.whl; do
            if [ -f "$wheel" ]; then
              echo "Would install: $(basename $wheel)"
              # pip install "$wheel"
            fi
          done
          
          # Add your package deployment logic here
          # Examples: upload to private package repository, deploy to application servers

      - name: Publish to PyPI
        if: inputs.deployment-target == 'pypi' && inputs.environment == 'prod'
        run: |
          echo "Publishing to PyPI"
          if [ -n "${{ secrets.PYPI_TOKEN }}" ]; then
            twine upload --repository pypi ./artifacts/* -u __token__ -p ${{ secrets.PYPI_TOKEN }}
          else
            echo "PYPI_TOKEN not provided, skipping publish"
          fi

      - name: Log in to Container Registry
        if: inputs.deployment-target == 'docker' && inputs.registry-url != ''
        uses: docker/login-action@v3.3.0
        with:
          registry: ${{ inputs.registry-url }}
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push Docker image
        if: inputs.deployment-target == 'docker'
        run: |
          if [ ! -f Dockerfile ]; then
            echo "Creating minimal Dockerfile for Python application"
            cat > Dockerfile << 'EOF'
          FROM python:3.11-slim
          
          # Set environment variables
          ENV PYTHONDONTWRITEBYTECODE=1
          ENV PYTHONUNBUFFERED=1
          
          # Install system dependencies
          RUN apt-get update && apt-get install -y \
              gcc \
              && rm -rf /var/lib/apt/lists/*
          
          # Set work directory
          WORKDIR /app
          
          # Install Python dependencies
          COPY artifacts/requirements.txt* ./
          RUN if [ -f requirements.txt ]; then pip install --no-cache-dir -r requirements.txt; fi
          
          # Copy application
          COPY artifacts/ .
          
          # Install built packages
          RUN find . -name "*.whl" -exec pip install {} \;
          
          # Create non-root user
          RUN groupadd -r appuser && useradd -r -g appuser appuser
          RUN chown -R appuser:appuser /app
          USER appuser
          
          EXPOSE 8000
          CMD ["python", "-m", "app"]
          EOF
          fi
          
          docker build -t ${{ inputs.registry-url }}/python-app:${{ inputs.version }} .
          docker push ${{ inputs.registry-url }}/python-app:${{ inputs.version }}
        working-directory: "${{ inputs.working-directory }}"

      - name: Deploy to Kubernetes
        if: inputs.deployment-target == 'k8s'
        run: |
          echo "Deploying to Kubernetes cluster for ${{ inputs.environment }}"
          # Add kubectl deployment logic here
          # kubectl apply -f k8s/
          # kubectl set image deployment/python-app python-app=${{ inputs.registry-url }}/python-app:${{ inputs.version }}

      - name: Deploy serverless function
        if: inputs.deployment-target == 'serverless'
        run: |
          echo "Deploying Python serverless function to ${{ inputs.environment }}"
          # Add serverless deployment logic here
          # Examples: AWS Lambda, Google Cloud Functions, Azure Functions

      - name: Install and configure application
        if: inputs.deployment-target == 'package'
        run: |
          echo "Installing Python application for ${{ inputs.environment }}"
          
          # Create virtual environment for deployment
          python -m venv deploy_env
          source deploy_env/bin/activate
          
          # Install wheels
          for wheel in ./artifacts/*.whl; do
            if [ -f "$wheel" ]; then
              pip install "$wheel"
            fi
          done
          
          # Run any post-installation scripts
          echo "Application installed successfully"

      - name: Health check
        run: |
          echo "Performing health check for ${{ inputs.environment }} deployment"
          # Add health check logic here
          # Examples: import package, run basic functionality test
          sleep 5
          echo "Health check passed"

      - name: Notify deployment success
        run: |
          echo "Successfully deployed Python application version ${{ inputs.version }} to ${{ inputs.environment }}"
          echo "Deployment target: ${{ inputs.deployment-target }}"

  createBug:
    name: Create Bug
    needs: [deploy]
    if: failure()
    uses: ./.github/workflows/create-bug.yml
    with:
      runs-on: ${{ fromJSON(inputs.runs-on) }}
      title: 'Python Deployment Failed'
      job: 'deploy'
      status: 'failure'
