# x-release-please-version
name: 'Deploy Rust'

permissions:
  contents: read
  id-token: write

on:
  workflow_call:
    inputs:
      runs-on:
        description: Additional required tags for the pipeline agents to use.
        required: true
        type: string
      working-directory:
        description: 'Directory to use for deployment'
        type: string
        required: false
        default: ./
      environment:
        description: Environment to deploy to (dev, staging, prod)
        type: string
        required: true
      artifact-name:
        description: Name of the artifact to download from build
        type: string
        required: true
      version:
        description: Semantic version being deployed
        type: string
        required: false
        default: 0.0.1-alpha
      registry-url:
        description: Container registry URL for Docker deployments
        type: string
        required: false
        default: ''
      deployment-target:
        description: Deployment target (binary, docker, k8s, serverless, crates)
        type: string
        required: false
        default: 'binary'
      image-name:
        description: Docker image name for container builds
        type: string
        required: false
      publish-environments:
        description: "Comma-separated list of environments where crates.io publishing is allowed"
        type: string
        required: false
        default: "prod"

    secrets:
      DEPLOY_TOKEN:
        description: Token for deployment authentication
        required: false
      REGISTRY_PASSWORD:
        description: Container registry password
        required: false
      CRATES_IO_TOKEN:
        description: Token for publishing to crates.io
        required: false

jobs:
  deploy:
    name: Deploy Rust application
    runs-on: ${{ fromJSON(inputs.runs-on) }}
    environment: ${{ inputs.environment }}

    steps:
      - name: Clean Agent Workspace
        uses: tiacsys/clean-after-action@v3.0.0

      - name: Checkout Repo
        uses: actions/checkout@v5.0.0

      - name: Set up Rust
        if: inputs.deployment-target == 'crates'
        uses: dtolnay/rust-toolchain@stable

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: ${{ inputs.artifact-name }}
          path: ./artifacts

      - name: Make binaries executable
        if: inputs.deployment-target == 'binary'
        run: |
          if ls ./artifacts/* >/dev/null 2>&1; then
            for binary in ./artifacts/*; do
              if [ -f "$binary" ] && ([ -x "$binary" ] || [[ "$binary" == *.exe ]]); then
                chmod +x "$binary" 2>/dev/null || true
                echo "Binary: $(basename "$binary")"
              fi
            done
          else
            echo "No binaries found in ./artifacts/"
          fi
          ls -la ./artifacts/

      - name: Deploy binary artifacts
        if: inputs.deployment-target == 'binary'
        run: |
          echo "Deploying Rust binaries to ${{ inputs.environment }}"
          # Add your binary deployment logic here
          for binary in ./artifacts/*; do
            if [ -f "$binary" ] && ([ -x "$binary" ] || [[ "$binary" == *.exe ]]); then
              echo "Would deploy: $(basename $binary) to ${{ inputs.environment }}"
              # Examples: scp to servers, upload to S3, copy to deployment directory
            fi
          done

      - name: Publish to crates.io
        if: inputs.deployment-target == 'crates'
        run: |
          echo "Publishing to crates.io"
          # Split publish-environments into array and check if current environment is allowed
          IFS=',' read -ra ALLOWED_ENVS <<< "${{ inputs['publish-environments'] }}"
          PUBLISH_ALLOWED=false
          for env in "${ALLOWED_ENVS[@]}"; do
            if [ "$env" = "${{ inputs.environment }}" ]; then
              PUBLISH_ALLOWED=true
              break
            fi
          done

          if [ "$PUBLISH_ALLOWED" = true ]; then
            if [ -n "${{ secrets.CRATES_IO_TOKEN }}" ]; then
              cargo login ${{ secrets.CRATES_IO_TOKEN }}
              cargo publish
            else
              echo "CRATES_IO_TOKEN not provided, skipping publish"
            fi
          else
            echo "Publishing to crates.io is not enabled for environment '${{ inputs.environment }}'."
            echo "Allowed environments: ${{ inputs['publish-environments'] }}"
          fi
        working-directory: "${{ inputs.working-directory }}"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}

      - name: Log in to Container Registry
        if: inputs.deployment-target == 'docker' && inputs.registry-url != ''
        uses: docker/login-action@v3.3.0
        with:
          registry: ${{ inputs.registry-url }}
          username: ${{ github.actor }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      # NOTE: A Dockerfile must exist in the specified working directory for Docker deployment.
      # The Dockerfile should define how to build your Rust application container image.
      # Example minimal Dockerfile:
      #   FROM rust:latest
      #   WORKDIR /app
      #   COPY . .
      #   RUN cargo build --release
      #   CMD ["./target/release/your-binary"]
      - name: Build and push Docker image
        if: inputs.deployment-target == 'docker'
        run: |
          if [ -z "${{ inputs.image-name }}" ]; then
            echo "ERROR: image-name input is required for Docker deployments."
            exit 1
          fi

          if [ ! -f Dockerfile ]; then
            echo "ERROR: No Dockerfile found in $(pwd)."
            echo ""
            echo "A Dockerfile is required in the working directory (${PWD}) to build the Docker image."
            echo "Please provide a reviewed, static Dockerfile that defines how to build your Rust application."
            echo ""
            echo "Example minimal Dockerfile:"
            echo "  FROM rust:latest"
            echo "  WORKDIR /app"
            echo "  COPY . ."
            echo "  RUN cargo build --release"
            echo "  CMD [\"./target/release/your-binary\"]"
            exit 1
          fi

          if [ -n "${{ inputs.registry-url }}" ]; then
            IMAGE_TAG="${{ inputs.registry-url }}/${{ inputs.image-name }}:${{ inputs.version }}"
          else
            IMAGE_TAG="${{ inputs.image-name }}:${{ inputs.version }}"
          fi
          docker build -t "$IMAGE_TAG" .
          if [ -n "${{ inputs.registry-url }}" ]; then
            docker push "$IMAGE_TAG"
          else
            echo "No registry-url provided, skipping docker push."
          fi
        working-directory: "${{ inputs.working-directory }}"

      - name: Deploy to Kubernetes
        if: inputs.deployment-target == 'k8s'
        run: |
          echo "Deploying to Kubernetes cluster for ${{ inputs.environment }}"
          # Add kubectl deployment logic here
          # kubectl apply -f k8s/
          # kubectl set image deployment/rust-app rust-app=${{ inputs.registry-url }}/rust-app:${{ inputs.version }}

      - name: Deploy serverless function
        if: inputs.deployment-target == 'serverless'
        run: |
          echo "Deploying Rust serverless function to ${{ inputs.environment }}"
          # Add serverless deployment logic here
          # Examples: AWS Lambda (with cargo lambda), Google Cloud Functions

      - name: Performance validation
        if: inputs.deployment-target == 'binary'
        run: |
          echo "Validating performance for Rust deployment"
          # Add performance testing/validation here
          echo "Performance validation passed"

      - name: Health check
        run: |
          echo "Performing health check for ${{ inputs.environment }} deployment"
          # Add health check logic here
          sleep 5
          echo "Health check passed"

      - name: Notify deployment success
        run: |
          echo "Successfully deployed Rust application version ${{ inputs.version }} to ${{ inputs.environment }}"
          echo "Deployment target: ${{ inputs.deployment-target }}"

  createBug:
    name: Create Bug
    needs: [deploy]
    if: failure()
    uses: ./.github/workflows/create-bug.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      title: 'Rust Deployment Failed'
      job: 'deploy'
      status: 'failure'
